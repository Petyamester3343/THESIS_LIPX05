using System.Globalization;
using System.Xml.Linq;

using static System.Console;

namespace Y0KAI_CDS
{
    internal class Program
    {
        public static bool isSilent = false;
        public static string
            inPath = string.Empty,
            outPath = string.Empty;

        static int Main(string[] args)
        {
            List<string> posArgs = [];
            
            // adding params
            foreach (string arg in args)
            {
                if (arg is "-s" or "--silent") isSilent = true;
                else if (File.Exists(arg) && arg.EndsWith(".xml", StringComparison.OrdinalIgnoreCase)) inPath = arg;
                else if (arg.EndsWith(".txt", StringComparison.OrdinalIgnoreCase)) outPath = arg;
                else posArgs.Add(arg);
            }

            if (string.IsNullOrWhiteSpace(inPath))
            {
                if (!isSilent)
                {
                    Error.WriteLine("Error: No valid input file provided!");
                    Hint();
                }
                return 1;
            }

            if (string.IsNullOrWhiteSpace(outPath)) outPath = "CampbellDudekSmith_Solution.txt";

            // file handling
            try
            {
                Graph g = ReadGraph(inPath!);
                if (g.Nodes.Count is 0)
                {
                    Error.WriteLine("No nodes found in the graph!");
                    return 2;
                }

                CDS solver = new(g);
                List<string> finalPathIDs = solver.Solve(isSilent);

                if (finalPathIDs.Count is 0)
                {
                    // This is the correct path for infeasible cycles found by the SA solver
                    if (!isSilent)
                        Error.WriteLine("No valid path found (optimization yielded only infeasible cycles).");
                    return 3;
                }

                using StreamWriter output = new(outPath);
                output.WriteLine("# Campbell-Dudek-Smith Solution (Generated by Y0KAI_CDS)\n# NODES:");
                foreach (string node in finalPathIDs)
                    output.WriteLine($"\tNODE {node}");

                return 0; // Success
            }
            catch (Exception ex)
            {
                // Must log the exception message to see *why* it stopped
                if (!isSilent)
                    Error.WriteLine($"Fatal error: {ex.Message}");
                return 4;
            }
        }

        // reads the graph's info and returns with a set-up Graph instance
        private static Graph ReadGraph(string filePath)
        {
            if (!File.Exists(filePath))
            {
                Error.WriteLine($"Error: File '{filePath}' does not exist.");
                Hint();
                throw new IOException("File does not exist");
            }

            try
            {
                Graph g = new();

                // root
                XDocument gFile = XDocument.Load(filePath);
                XElement? root = gFile.Element("SGraph");

                if (root is null)
                {
                    if (!isSilent) Error.WriteLine("ERROR: The graph file is malformed (missing root element).");
                    throw new FormatException("Malformed graph file!");
                }

                // nodes
                IEnumerable<XElement> nodes = root.Element("Nodes")?.Elements("Node") ?? [];
                foreach (XElement node in nodes)
                {
                    string
                        id = node.Attribute("ID")?.Value ?? throw new FormatException("Node missing ID"),
                        desc = node.Attribute("Desc")?.Value ?? string.Empty,
                        timeM1Str = node.Attribute("TimeM1")?.Value ?? "0",
                        timeM2Str = node.Attribute("TimeM2")?.Value ?? "0";

                    double
                        timeM1 = double.TryParse(timeM1Str, NumberStyles.Any, CultureInfo.InvariantCulture, out double t1) ? t1 : 0,
                        timeM2 = double.TryParse(timeM2Str, NumberStyles.Any, CultureInfo.InvariantCulture, out double t2) ? t2 : 0;

                    if (!string.IsNullOrWhiteSpace(id))
                        g.Nodes[id] = new()
                        {
                            ID = id,
                            Desc = desc,
                            TimeM1 = t1,
                            TimeM2 = t2
                        };
                }

                // edges
                IEnumerable<XElement> edges = root.Element("Edges")?.Elements("Edge") ?? [];
                foreach (XElement edge in edges)
                {
                    string
                        from = edge.Attribute("From")?.Value ?? throw new FormatException("Edge missing From attribute!"),
                        to = edge.Attribute("To")?.Value ?? throw new FormatException("Edge missing To attribute!"),
                        costStr = edge.Attribute("Cost")?.Value ?? throw new FormatException("Edge missing Cost attribute!");

                    if (!double.TryParse(costStr, NumberStyles.Any, CultureInfo.InvariantCulture, out double cost))
                        throw new FormatException($"Edge cost {costStr} is not a valid number");

                    if (g.Nodes.ContainsKey(from) && g.Nodes.ContainsKey(to) && !double.IsNaN(cost))
                        g.Edges.Add(new() { FromID = from, ToID = to, Cost = cost });
                    else
                    {
                        if (!isSilent) Error.WriteLine($"Warning: Edge from '{from}' to '{to}' with cost '{costStr}' is invalid and will be skipped.");
                    }
                }

                if (g.Nodes.Count is 0 && !isSilent)
                    Error.WriteLine("Warning: The graph contains no nodes.");

                return g;
            }
            catch (Exception ex)
            {
                if (!isSilent) Error.WriteLine($"Error reading graph from '{filePath}': {ex.Message}");
                throw;
            }
        }

        private static void Hint() =>
            Error.WriteLine("Usage: Y0KAI_CDS.exe <path_to_SGraph.xml> <path_to_Solution.txt> [-s | --silent]");
    }
}
